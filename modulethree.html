<!DOCTYPE HTML>
<html>
	<head>
		<title>Secure Software Development</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
		<style>
		.column3 {
  float: left;
  width: 33%;
}

		.column2 {
  float: left;
  width: 50%;
}

/* Clear floats after the columns */
.row:after {
  content: "";
  display: table;
  clear: both;
}
</style> 
	</head>
	<body class="is-preload">

			<div id="wrapper">

				
					<header id="header" class="alt style2">

						<nav>
							<a href="#menu">Menu</a>
						</nav>
					</header>

			
					<nav id="menu">
						<ul class="links">
														<li><a href="index.html">Home</a></li>
							<li><a href="glossary.html">Glossary</a></li>
							<li><a href="moduleone.html">Launching into Computer Science</a></li>
							<li><a href="moduletwo.html">Object-oriented Information Systems</a></li>
							<li><a href="modulethree.html">Secure Software Development</a></li>
						</ul>

					</nav>


		


					<section id="banner" class="style2">
						<div class="inner">
							<span class="image">
								<img src="images/pic07.jpg" alt="" />
							</span>
							<header class="major">
								<h1>Secure Software Development</h1>
							</header>
							<div class="content">
								<p>Module Three</p>
							</div>
						</div>
					</section>

					<div id="main">
						<section id="Content">
							<div class="inner">
								<header class="major">
									<h2>Contents</h2>
								</header>
								<a href="#one">Unit 1</a>
								<br>	
								<a href="#Two">Unit 2</a>
								<br>
								<a href="#three">Unit 3</a>	
								<br>
								<a href="#Four">Unit 4</a>	
								<br>
								<a href="#FiveAndSix">Units 5 and 6</a>	
								<br>
								<a href="#Seven">Unit 7</a>	
								<br>
								<a href="#Eight">Unit 8</a>	
								<br>
								<a href="#NineAndTen">Units 9 and 10</a>	
								<br>
								<a href="#ElevenAndTwelve">Units 11 and 12</a>	
								<br>
								<a href="#OtherResources">Other Resources</a>		
							
							</div>
							</Section>
								
							


									<div id="main">
										<section id="one">
											<div class="inner">
												<header class="major">
													<h2>Unit 1 - Introduction to Secure Software Development</h2>
												</header>



<b><a href="https://jonny-droid.github.io/e-Portfolio/ssd-unit1.html">Please see here for the artifacts</a></b>
<p></p>

The difference between <b>architecture</b> and <b>design</b>: architecture is concerned with "what" and "where". 
The non-functional requirements, business requirements etc... Often drawn with class diagrams to demonstrate subsystem relationships. Software design is concerned with the "how" and includes low level stuff such as classes, functions and components. The architecture should be determined before the software design starts. 
Various types of "architects" exist within IT:
<p>
<img src="https://jonny-droid.github.io/e-Portfolio/images/architectRoles.JPG">
</br>
Figure: Scope and focus of various architect roles in a software organization(Pillai, 2017: 17) </p>
The Open Group Architecture Framework (TOGAF): is the most popuplar enterprise architecture methodology
<p>
</p>								
Two main types of software methodologies exist:
<div class="row">
<div class="column2"><h3>Predictive (waterfall)</h3>
<p>
<ul>
<li>Each phase depends on the preceding phase</li>
<li>Each phase needs signing off</li>
<li>Testing begins after coding is completed</li>
<li>One problem is that issues often only arrise at the end during testing, and it is very difficult and costly if need to go back to previous phase during testing</li>
<li>A spiral methodology has been proposed, this where risk is thought about throughout the project rather than just at one stage</li>

</ul>
</p>
  
  
  </div>
  <div class="column2"><h3>Adapative (agile)</h3>
    <p>
<ul>
<li>Iterative - so can easily move to preceding phases without incurring a huge cost</li>
<li>The Agile Manifesto: working software is more important than comprehensive documentation (i.e. do not produce more documentation than is absolutely necessary)</li>
<li>One problem is that there might not be time at the end to execute in-depth testing</li>
</ul>	

Examples include:
<ul>
<li>Scrum: sharing coding tasks between a team and communicating delay regarding sprints (time frame that certain tasks needs to take place in)</li>
<li>Paired programming (comes under the umbrella of extreme programming): two developers work at one PC. One writes the code while the other observes. Swap roles frequently</li>
<li>The dynamic systems development module: develop the system as quickly as possible</li>
<li>Test Driven Development: test written before the code. Code needs to ensure test is passed. Good for high quality code</li>
</ul> 
  </p> 
  </div>
<p>
Several standardisation bodies and projects are relevant to this module:
<ul>
<li>
W3C: the main international standards body for the World Wide Web.
</li>
<li>
ISOC: how the internet is developed and used.
</li>
<li>
NIST: body for technology standards in general (US)
</li>
<li>
ISO/IEC: ICT standards
</li>
<li>Open Web Application Security Project (OWASP): work to improve software security. Contributors include Panasonic and Accenture. Have produced a checklist to develop a secure system. Recommends three levels of verifcation based on the sensitivity and use of data.</li>

</ul>

</div>

</p>
Key terms to look at in the <a href="glossary.html">Glossary</a> for this unit:
<ul>
<li>Latency</li>
<li>Quality attributes (architecture)</li>
</ul>
								</div>
								</section>
					<div id="main">
							<section id="Two">
								<div class="inner">
									<header class="major">
										<h2>Unit 2 - UML Modelling to Support Secure System Planning</h2>
									</header>
									<br>
<b><a href="https://jonny-droid.github.io/e-Portfolio/ssd-unit2.html">Please see here for the artifacts</a></b>
<p></p>
Standardised by the Object Management Group
</br>
Can be useful both between developer and also between developers/project managers and customers. Also useful for long-term maintenance of code.
<br>
Can be divided into two types: structural diagrams (static) and behavioural diagrams (dynamic events - interactions between objects and internal logic)
<br>
UML models are made up of three categories of elements:
<ul>
<li>Classifier: object within the systen</li>
<li> Event: occurence within the system</li>
<li>Behaviours: reactions to events</li>
</ul>
Various types of diagrams exist:
<ul>
<li>Use Case diagrams: user stories. Requirements of the system for the sytem to fulfil its business purpose</li>
<li>Activity diagrams: order in which activities are executed and happen as the result of a particular activity (e.g. if correctly complete a form this happens, if incorrerctly complete then this happens</li>
<li>Sequence diagrams: can be read both left to right and top to bottom.</li>

</ul>


Different types of diagrams used at different stages of the SDLC:
<ul>
<li>Early stages: use diagrams to capture all functionalities of the system</li>
<li>Design stages: class diagrams to model the objects which will be needed</li>
<li>Information and data phase: sequence diagrams</li>
</ul>

</p>
Key terms to look at in the <a href="glossary.html">Glossary</a> for this unit:
<ul>


</ul>
								</div>
							</section>
					<div id="main">
							<section id="three">
								<div class="inner">
									<header class="major">
										<h2>Unit 3 - Programming Languages: History, Concepts & Design</h2>
									</header>
<b><a href="https://jonny-droid.github.io/e-Portfolio/ssd-unit3.html">Please see here for the team activity artifact</a></b>
<br>
<b><a href="https://jonny-droid.github.io/e-Portfolio/ssd-unit3BufferOverflow.html">Please see here for the codio artifact</a></b>
<p></p>
<h2>How programming languages convert instructions into native code:</h2>

<p>
<div class="row">
  <div class="column3"><h3>Compiled language (e.g. C, C++, Objective-C):</h3>
<p>
<ul>
<li>Write code and then a programme called a compiler will create a separate file containing the machine code</li>
<li>Can be faster as the code has already been converted into machine code for the end user</li>
<li>End user never sees the source code</li>
<li>Can be slower to debug and change due to compiler process</li>
</ul>
</p>
  </div>
  <div class="column3"><h3>Intepreted/scripting language (e.g.PhP and JavaScript)</h3>
    <p>
<ul>
<li>Give a copy of source code to the end user</li>
<li>Does not save as a separate machine code file. Everything done on the end-user's machine. I.e. gives instructions to software on the end-user's computer</li>
<li>Example of JavaScript. End-user's web browser interprets the code</li>
<li>Is independent of type of machine/OS. End-user's machine takes care of the code. They need to install the relevant intepreter</li>
<li>Easier to debug as always have access to all of the source code</li>
<li>Can be slower as needs to be interpreted each time it is run (the compiler has already done this for the end user in compiled code)</li>
</ul>	

  </p> 
  </div>
    
  <div class="column3"><h3>Hybrid language/byte code (e.g. Java, VB.net, Python, C#)</h3>
    <p>
<ul>
<li>
Compiles part way to an intermediate language.
</li>
<li>End user computer only has to interpet the final steps</li>
<li>Often executed on a virtual machine</li>
</ul>
  </p> 
  </div>
</div>
A Command Line Interface (CLI) connects the user directly to a programme or Operating System. The command line intepreter is the programme that handles this interface.
</p>
</p>
<h2>Programming paradigms:</h2>
Most programming languages are multi-paradigm
</br>
Not everything neatly fits into these paradigms

</p>
<div class="row">
  <div class="column2"><h3>Imperative programming </br> (programmer defines how to complete a task)</h3>
    <p>
<ul>
<li>Procedural programming paradigm: series of commands to be carried out in order to achieve an outcome. Often what people new to programming learn. Focusses on assigning values to variables. Statements usually start with a verb. </li>
<li>Object-orientated programming paradigm: code broken down into objects which have their own properties and perform different actions. Usually statements start with an object/class. Classes are easily reused.</li>

</ul>
</p>

</p>
  </div>
  <div class="column2"><h3>Declarative programming </br>(programmer focuses on defining the problem).</h3>
    <p>
<ul>
<li>Logical programming paradigm: based on formal logic. Associated with machine learning and AI</li>
<li>Functional programming paradigm: execution of functions. Interpreter fills in the details</li>
  </ul>	
  </p> 

  </div>
  </div>
<h2>Handling data types</h2>
<p>
<div class="row">
  <div class="column2"><h3>Static typing (.e.g Java, C, C++ and Go)</h3>
    <p>
<ul>
<li>Requires the programmer to explicitly define the data type when creating it (e.g. when preceiding with an <i>int</i> when defining a variable)</li>
<li>Statically typed languages are generally compiled</li>
<li>Has the advantage that by telling the computer upfront what data you are dealing with, errors can be caught before deployment. Also errors can be more obvious</li>
</ul>
</p>

</p>
  </div>
  <div class="column2"><h3>Dynamic typing (e.g. Python, JavaScript, PhP and Pearl)</h3>
    <p>
<ul>
<li>Language guesses our data type (.e.g whether a string, integer or float)</li>
<li>Generally interpreted languages</li>
<li>One advantage is potentially less code needed, as not having to define data type each time</li>
<li>Can be more flexible as same variable can have a different type at different times during the execution</li> 
</ul>
</div>
</div>

</p>
Key terms to look at in the <a href="glossary.html">Glossary</a> for this unit:
<ul>
<li>Assembly language</li>
<li>Runtime</li>
<li>Source code</li>
</ul>

</ul>
								</div>
							</section>
					<div id="main">
							<section id="Four">
								<div class="inner">
									<header class="major">
										<h2>Unit 4 - Exploring Programming Language Concepts</h2>
									</header>
<b><a href="https://jonny-droid.github.io/e-Portfolio/ssd-unit4.html">Please see here for the artifact</a></b>
<p></p>
Three aspects of secure architecture (CIA triad):
<ul>
<li>Confidentialility: restrict unauthorised use of data</li>
<li>Integrity: system free from external manipulation, i.e. data can be trusted</li>
<li>Availability: level of service corresponds with its SLA. Also, system will not deny service to authorised users</li>
</ul>
The following helps to achieve this:
<ul>
<li>Authentication (verifies identity, e.g. public keys)</li>
<li>Authorisation (rights to specific users</li>
<li>Non-reputability (a user cannot deny behaviour or transactions on a system</li>
</ul>
Design patterns: these are guidelines to organise code for common problems in a way that is widely accepted by the software community. 
They are usually language netral, and details the name and structure of the solution (this also makes them readily identifiable).
They are not algarithms (i.e. step by step solutions) nor software architecture (which is the framework within which coding is housed).
<p>
Design antipatterns: these are where a pattern does not exist for a particular problem. 
An anti-pattern is something that appears to be an appropriate solution, but is not. 
These antipatterns have already been proved ineffective so exist to save programmers from wasting their time with these.
</p>
<p>Design errors/coding smells: antipatterns, these indicate a potential bug in the application</p>
<p>Particularly important terminology from this week (some programers use the below terms interchangeably and not in the correct way):</p>
<ul>
<li>Python script: a file containing commands in a logical order. Has to produce an output. Intended to be run directly.</li>
<li>Python module: can inport into script, but does not run in itself.</li>
<li>Python packages: a collection of related modules taht come bundled together  </li>
<li>Python standard library: a collection of modules and packages that come with the standard python installation and can just import into your scripts, e.g. JSON</li>
</ul>

</p>
Recursion is a function that calls itself. It is a way of dividing problems into smaller problems that can use the same algorithm. 
Must have an end condition to know if should recall itself or not. Associated heavily with functional programming.
</p>

Key terms to look at in the <a href="glossary.html">Glossary</a> for this unit:
<ul>
<li>Casting</li>
<li>Code refractoring</li>
<li>Garbage collection</li>
<li>Inheritance </li>
<li>Pointers</li>
<li>Polymorphism</li>
<li>Queue</li>


</ul>

								</div>
							</section>
					<div id="main">
							<section id="FiveAndSix">
								<div class="inner">
									<header class="major">
										<h2>Unit 5: An Introduction to Testing</br>
										Unit 6: Using Linters to Support Python Testing</h2>
									</header>
<b><a href="https://jonny-droid.github.io/e-Portfolio/ssd-unit6.html">Please see here for the artifact</a></b>
<p></p>
Validation is the ability to fulfil the customers need. 
Verification is the ability to fulful the defined specification. Both are needed, but sometimes only one of these is met.
<p>
Quality assurance testing is the process of ensuring the quality of the software being released.
</p>
Developing a test plan includes:
<ul>
<li>What type of testing?</li>
<li>What needs testing and when?</li>
</ul>
<p>
White-box testing looks at the structure of the code. It invovles the internal system being known to the tester. 
An example of this is unit testing. These structural based test (i.e. they consider the structure of the system).
<br>
Black-box testing looks at the overall functionality (for example equivalency or use-case testing). 
Can start designing black-box testing before the code is even written. These are specification based  (i.e. the tester can find missing functionalities).
</p>
There are many benefits of automating testing. Some areas cannot be automated easily, for example user-acceptability testing.

</p>
There are various approaches to testing (it is good practice to include as many of these as possible):

<ul>
<li>Functional testing: customer requirements from the specification have been fulfilled.</li>
<li>Usability testing: a user evaluates the system.</li>
<li>Compatability testing: works on different hardware and software platforms.</li>
<li>Regression testing: changes to the system have not stopped a component working.</li>
<li>Acceptance testing: will the system fuilfill the user requirments enough for them to accept it (can involve the developer working with the customer).</li>
<li>Performance testing: does it meet perfrmances requirements (for example load or stress testing).</li>
<li>Big bang testing: testing the system as a whole</li>
</p>
Security related approach:
<ul>
Vulnerability assessment and penetration testing. The former helps us to determine where we need to do penetration testing (which is the simulation of an attack/putting a system under pressure).
</ul>
<p>
Testing can also be divided into dynamic (carried out while the code is being run) and static (based upon the internal structure of the software). These work well together, with the latter validating the findings of the former.
</p>
Experience-based testing involves the tester using their knowledge to guess where erros may exist.
</p>
Linters: a lint is a small mistake in code. A linter helps to indentify these. Most IDEs run these in the background. 
Some are language independent and some are specific. Python specific examples include Flake8 and PyLint.
</p>
</p>

Key terms to look at in the <a href="glossary.html">Glossary</a> for this unit:
<ul>
<li>Cyclometric complexity</li>
<li>Poison package</li>
<li>Testability</li>
</ul>



								</div>
							</section>
					<div id="main">
							<section id="Seven">
								<div class="inner">
									<header class="major">
										<h2>Unit 7: Introduction to Operating Systems</h2>
									</header>
<b><a href="https://jonny-droid.github.io/e-Portfolio/ssd-unit7.html">Please see here for the artifact</a></b>																		
An Operating system is a programme to run all other software and hardware.
A key part of the operating system is to hide all the below functions from the end user (essentially it provides an absraction layer).
<br>
There are four main functions of an OS:
<ol>
<li>Providing a number of interfaces</li>
	<ul>
	<li>Graphical User Interface (GUI)</li>
	<li>Command Line Interface (CLI)</li>
	<li>API (providing an interface for other programmes)</li>
	<li>Device Drivers</li>
	</ul></li>

<li>Resource management and scheduling
<ul>
<li>CPU</li>
<li>Memory and file systems</li>
<li> (please see the below information on the kernel)</li>
</ul>
</li>
<li>Abstraction and virtualisation (commonly used in virutal hosting environments). This may include:
<ul>
<li>Simulating hardware functionality (i.e. creating a virtual system from a single server)</li>
<li>OS virtualisation: software to allow a piece of hardware to run multiple OSs (can also relate to virtual machines sharing an operating system, rather than each having their own OS (which can be seen as inefficient))</li>
</ul>
</li>
<li>Services (for example a print service involving spooling data) and security </li>
</ol>
The kernel is the core of the OS. It is the first programme to load when the system starts and is stored in memory
until the system is closed down.
<br>
The kernel is responsible for:
<ul>
<li>Managing hardware</li>
<li>Managing memory</li>
<li>Process/task management (when a programme runs we call it a process)</li>
</ul>


</ul>
								</div>
							</section>
					<div id="main">
							<section id="Eight">
								<div class="inner">
									<header class="major">
										<h2>Unit 8: Cryptography and Its Use in Operating Systems</h2>
									</header>
<b><a href="https://jonny-droid.github.io/e-Portfolio/ssd-unit8.html">Please see here for the artifact</a></b>	
<b>Saltzer and Schroeder Principles 1975 [reference]:</b><br>
These still seem relevant, especially:
<ul>
<li>Open Design (security is not achieve through keeping source code or processes secret)</li>
<li>Least Privelege: anyone who gains has access should be given the minimum level needed to perform their tasks.</li>
<li>Psychological acceptability: should be intuitive and designed for ease of use.</li>
</ul>
</p>																	
Secure proctocols (e.g. HTTPS) usually use Public Key Infrastructure (PKI). This includes the swapping of public keys between the two parties (private keys are never swapped). 
Public and private keys are related through a very complicated mathematical relationship. 

<p>
<img src="https://jonny-droid.github.io/e-Portfolio/images/PKI.JPG">
</br>
Figure 2: An image showing how PKI works (drawn by myself)
<p>
As well as keys, the other part of PKI are SSL/TLS certificates. This is how I know that it was really the server who sent me their public key, and not someone else pretending to be them (and sending their own public key). 
To ensure this we need digital certificates. These are usually issues by certified public authorities (who are also able to revoke certificates).
</p>
Other information from this unit included:
<ul>
<li>The need for audits</li>
<li>The problem of legacy code</li>
<li>The use of proxy servers (security benefits of adding an additional security layer, obscuring IP addresse, controlling employee interet usage, and also side benefits such as improving performance by caching data</li>
<li>Firewalls (to act as an intermediary between your internal network and outside traffic</li>
</ul>
</p>
Key terms to look at in the <a href="glossary.html">Glossary</a> for this unit:
<ul>
<li>Double strength encryption</li>
<li>Hybrid cryptography</li>
</ul>
								</div>
							</section>
					<div id="main">
							<section id="NineAndTen">
								<div class="inner">
									<header class="major">
									<h2>Unit 9: Developing an API for a Distributed Environment
									</br>Unit 10: From Distributed Computing to Microarchitectures</h2>
									</header>
<b><a href="https://jonny-droid.github.io/e-Portfolio/ssd-unit9.html">Please see here for the unit 9 artifact</a></b>
<b>Monlithic Architecture:</b></br>
A single software product, that will usually grow over time. Works well with small applications and small teams.
Disadvantages include that it has a low fault tolerance, is difficult to update and that if one
part of the system breaks it can cause the whole to fail.
</p>
<b>Distributed systems:</b></br>
A collection of individual components located on different machines. Working together to achieve a common goals.
</br>
A microservice architecture is becoming increasingly common. This is where applications are developed as several
small independent suites. For example, a system might have a user interface, stock control, shipping etc...
Many businesses use microservices. They are organised around business capabilities, with each providing a different
function. Communication between systems may be achieved via https. An API gateway is used by the client to access
the microservice capability.
</p>
Advantages include:
<ul>
<li>It works well with an agile approach to development.</li>
<li>Utilises small specialist teams.</li>
<li>Can use different technologies for different services, depending on the expertise within each team.</li>
<li>A failure of one microservice will not mean that the application is unusable.</li>
</ul>
One disadvantage is that the attack surfaces of the application are increased.
For example data being stored in different places increase the attack surfaces.

<br>Increases attack surfaces, as for example data is stored at multiple locations.
<p></p>
For then end-user there is not difference between monolithic and microservices.

<p></p>
What is an ontology?<br>
An ontology is method of knowledge management within a domain/organisation.
Data exists in various formats, for example excel files, databases, uml, text files etc...
We need a way of making sense of this information. There are various frameworks that exist offering
ways of doing this. An example of an ontology diagram:
<p></p>
<img src="https://jonny-droid.github.io/e-Portfolio/images/exampleOntology.JPG">


								</div>
							</section>
					<div id="main">
							<section id="ElevenAndTwelve">
								<div class="inner">
									<header class="major">
										<h2>Unit 11: Future trends in Secure Software Development
										<br>Unit 12: The Great Tanenbaum-Torvalds Debate Revisited</h2>
										</h2>
									</header>
<b><a href="https://jonny-droid.github.io/e-Portfolio/ssd-unit11.html">Please see here for the unit 11 artifact</a></b>	
Blockchain is being held by some to be a solution to web security (as with most panacea's, this is not the case).
For more information on Blockchan <a href="oopunit12.html" please view this link from my last module.></a>
<p>
There are OSs that have been developed just for IOT devices. These include TinyOS, Contiki OS and MBed OS.
These are suited for IOT devices which are often lower power, can have a relatively low speeds and limited RAM.
<p>
Green IT is an emerging area. Especially as technologies such as blockchain can be require large amounts of electricity.
</p>
Fog computing involves extended services offered by the cloud to edge devices. It allows processes to take place at a distributed level.
An example of this is that modern trains have units to process information collected from the track. Then if the train device finds an issue, it will upload this to the cloud.
(Realwire, 2018). Instead of cloud &#8594; device, it is cloud &#8594; fog &#8594; device.
<p>
Advantages of fog computing are that it removes issues to do with latency and an unreliable internet connection, it can improve security, and
reducing the amount of data travelling long distances can result in environmental benefits.
</p>
Key terms to look at in the <a href="glossary.html">Glossary</a> for this unit:
<ul>
<li>Cyber Physical Systems (CPS)</li>
<li>DevOpsSec</li>
<li>Instrastructure as code</li>


</ul>
								</div>
							</section>
							<section id="OtherResources">
								<div class="inner">
									<header class="major">
										<h2>Other Resources</h2></header>
<b><a href="https://jonny-droid.github.io/e-Portfolio/PDFs/teamwork.pdf">Everything teamwork related</a></b></p>
<b><a href="https://jonny-droid.github.io/e-Portfolio/PDFs/SkillsMatrix3.pdf">Skills Matrix</a></b></p>
<b><a href="https://jonny-droid.github.io/e-Portfolio/PDFs/ActionPlanMod3.pdf">Action Plan</a></b></p>
<b><a href="https://jonny-droid.github.io/e-Portfolio/PDFs/designVsImplementation.pdf">Evaluation of the final project versus Design proposal </a></b>
</p>
</p>
<h2>References:</h2>
Pillai, A.B. (2017) Software Architecture with Python. Birmingham, UK. Packt Publishing Ltd.
</p>
Realwire. (2018) Veea Systems and Angel Trains Work Together to Showcase the Potential of Edge Computing in Rail at HackTrain 5.0. Available from: 
https://www.realwire.com/releases/Veea-Systems-Angel-Trains-Work-Together-to-Showcase-Edge-Computing-in-Rail [Accessed 29th October 2021].

</section>
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>
	</body>
</html>

