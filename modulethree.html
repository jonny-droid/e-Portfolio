<!DOCTYPE HTML>
<html>
	<head>
		<title>Secure Software Development</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
		<style>
		.column3 {
  float: left;
  width: 33%;
}

		.column2 {
  float: left;
  width: 50%;
}

/* Clear floats after the columns */
.row:after {
  content: "";
  display: table;
  clear: both;
}
</style> 
	</head>
	<body class="is-preload">

			<div id="wrapper">

				
					<header id="header" class="alt style2">

						<nav>
							<a href="#menu">Menu</a>
						</nav>
					</header>

			
					<nav id="menu">
						<ul class="links">
														<li><a href="index.html">Home</a></li>
							<li><a href="glossary.html">Glossary</a></li>
							<li><a href="moduleone.html">Launching into Computer Science</a></li>
							<li><a href="moduletwo.html">Object-oriented Information Systems</a></li>
							<li><a href="modulethree.html">Secure Software Development</a></li>
						</ul>

					</nav>

			
					<section id="banner" class="style2">
						<div class="inner">
							<span class="image">
								<img src="images/pic07.jpg" alt="" />
							</span>
							<header class="major">
								<h1>Secure Software Development</h1>
							</header>
							<div class="content">
								<p>Module Three</p>
							</div>
						</div>
					</section>

				<!-- Main -->
					<div id="main">

						<!-- One -->
							<section id="one">
								<div class="inner">
									<header class="major">
										<h2>Unit 1 - Introduction to Secure Software Development</h2>
									</header>


Software Development Lifecycle (SDLC) framework:
<p>





<p>
</p>

The difference between <b>architecture</b> and <b>design</b>: architecture is concerned with "what" and "where". The non-functional requirements, business requirements etc... Often drawn with class diagrams to demonstrate subsystem relationships. Software design is concerned with the "how" and includes low level stuff such as classes, functions and components. The architecture should be determined beefore the software design starts. 
Various types of "architects" exist within IT:
<p>
<img src="https://jonny-droid.github.io/e-Portfolio/images/architectRoles.JPG">
</br>
Figure: Scope and focus of various architect roles in a software organization(Pillai, 2017: 17) </p>
The Open Group Architecture Framework (TOGAF): most popuplar enterprise architecture methodology
<p>
</p>




<ul>



</ul>
									
Two main types of software methodologies exist:
<div class="row">
  <div class="column2"><h3>Predictive (waterfall)</h3>
<p>
<ul>
<li>Each phase depends on the preceding phase</li>
<li>Each phase needs signing off</li>
<li>Testing begins after coding is completed</li>
<li>One problem is that issues often only arrise at the end during testing, and it is very difficult and costly if need to go back to previous phase duringn testing</li>
<li>A spiral methodology has been proposed, this where risk is thought about throughout the project rather than just at one stage</li>

</ul>
</p>
  
  
  </div>
  <div class="column2"><h3>Adapative (agile)</h3>
    <p>
<ul>
<li>Iterative - so can easily move to preceding phases without incurring a huge cost</li>
<li>The Agile Manifesto: working software is more important than comprehensive documentation (i.e. do not produce more documentation than is absolutely necessary</li>
<li>One problem is that there might not be time at the end to executre in-depth testing</li>
</ul>	

Examples include:
<ul>
<li>Scrum: sharing coding tasks betwenm a team and communicating delay regarding sprints (time frame that certain tasaks needs to take place in)</li>
<li>Paired programming (comes under the umbrella of extreme programming): two devleopers work oat one PC. One writes teh code while the otehr observes. Swap roles frequently</li>
<li>The dynamic systems development module: develop the system as quickly as possible</li>
<li>Test Driven Development: test written before teh code. Code needs to ensure test is passed. Good for high quality code</li>
</ul> 
  </p> 
  </div>
<p>
Several standardisation bodies and projects are relevant to this module:
<ul>
<li>
W3C: the main international standards body for the World Wide Web.
</li>
<li>
ISOC: how the internet is developed and used.
</li>
<li>
NIST: body for technology standards in general (US)
</li>
<li>
ISO/IEC: ICT standards
</li>
<li>Open Web Application Security Project (OWASP): work to improve software security. Contributors include Panasonic and Accenture. Have produced a checklist to develop a secure system. Recommends three levels of verifcation based on the sensitivity and use of data.0</li>

</ul>

  
   
</div>



</p>
Key terms to look at in the <a href="glossary.html">Glossary</a> for this unit:
<ul>
<li>Microservice applcation</li>
<li>Monolith application</li>
<li>Cryptography</li>
<li>API</li>
<li>Domain ()</li>
<li>Latency</li>
<li>Quality attributes (architecture)</li>
</ul>
								</div>
							
												
				<!-- Main -->
					<div id="main">

						<!-- two -->
							<section id="Two">
								<div class="inner">
									<header class="major">
										<h2>Unit 2 - UML Modelling to Support Secure System Planning</h2>
									</header>
<br>
Standardised by the Object Management Group
</br>
Can be useful both bewteen develoerspers and also between developers/project managers and customers. Also useful for long-term maintenance of code.
<br>
Can be divided into two types: structural diagrams (static) and behavioural diagrams (dynamic events - interactions between objects and internal logic)
<br>
UML models are made up three categories of elements:
<ul>
<li>Classifier: object within teh systen</li>
<li> Event: occurence within the system</li>
<li>BehavioursL reactions to events</li>
</ul>
Various types of diagrams exist:
<ul>
<li>Use Case diagrams: user stories. Requirements of teh system for the sytem to fulfil its business purpose</li>
<li>Activity diagrams: order in which activities are executed and happen as the result of a particular activity (e.g. if correctly complete a form this happens, if incorrerctly copmlete then this happens</li>
<li>Sequence diagrams: can be read both left to right and top to bottom.....</li>

</ul>


Different types of diagrams used at different stages of the SDLC:
<ul>
<li>Early stages: use diagrams to caputre all functionalities of the system</li>
<li>Design stages: class diagrams to model the objects which will be needed</li>
<li>Information and ata phase: sequence diagrams</li>
</ul>

</p>
Key terms to look at in the <a href="glossary.html">Glossary</a> for this unit:
<ul>


</ul>
								</div>
							</section>
											<!-- Main -->
					<div id="main">

						<!-- two -->
							<section id="Two">
								<div class="inner">
									<header class="major">
										<h2>Unit 3 - Programming Languages: History, Concepts & Design</h2>
									</header>
<h2>How programming languages convert instructions into native code:</h2>

<p>
<div class="row">
  <div class="column3"><h3>Compiled language (e.g. C, C++, Objective-C):</h3>
<p>
<ul>
<li>Write code and then a programme called a compiler will create a separate file containing the machine code</li>
<li>Can be faster as the code has already been converted into machine code for the end user</li>
<li>End user never sees the source code</li>
<li>Can be slower to debug and change due to compiler process</li>
<li></li>


</ul>
</p>
  </div>
  <div class="column3"><h3>Intepreted/scripting language (e.g.PhP and JavaScript)</h3>
    <p>
<ul>
<li>Give a copy of source code to the end user</li>
<li>Ddes not save as a separate machine code file. Everything done on the end-user's machine. I.e. gives instructions to software on the end-user's computer</li>
<li>Example of JavaScript. End-user's web browser interprets the code</li>
<li>Is independent of type of machine/OS. End-user's machine takes care of the code. They need to install the relevant intepreter</li>
<li>Easier to debug as always have access to all of the source code</li>
<li>Can be slower as needs to be intrepreted each time it is run (the compiler has already done this for the end user in compiled code)</li>
</ul>	

  </p> 
  </div>
    
  <div class="column3"><h3>Hybrid language/byte code (e.g. Java, VB.net, Python, C#)</h3>
    <p>
<ul>
<li>
Compiles part way to an intermediate language.
</li>
<li>End user computer only has to interpet the final steps</li>
<li>Often executed on a virtual machine</li>
</ul>
  </p> 
  </div>
</div>
A Command Line Interface (CLI) connects the user directly to a programme or Operating System. The command line intepreter is the programme that handles this interface.
</p>
</p>
<h2>Programming paradigms:</h2>
Most programming languages are multi-paradigm
</br>
Not everything neatly fits into these paradigms

</p>
<div class="row">
  <div class="column2"><h3>Imperative programming </br> (programmer defines how to complete a task)</h3>
    <p>
<ul>
<li>Procedural programming paradigm: series of commands to be carried out in order to achieve an outcome. Often what people new to programming learn. Focusses on assigning values to variables. Statements usually start with a verb. </li>
<li>Object-orientated programming paradigm: code broken down into objects which ahve their own properties and perform different actions. Usually statements start with an object/class. Classea are easily reused. See .... for more information.</li>

</ul>
</p>

</p>
  </div>
  <div class="column2"><h3>Declarative programming </br>(programmer focuses on defining the problem).</h3>
    <p>
<ul>
<li>Logical programming paradigm: based on formal logic. Associated with machine learning and AI</li>
<li>Functional programming paradigm: execution of functions. Interpreter fills in the details</li>
  </ul>	
  </p> 

  </div>
  </div>
<h2>Handling data types</h2>
<p>
<div class="row">
  <div class="column2"><h3>Static typing (.e.g Java, C, C++ and Go)</h3>
    <p>
<ul>
<li>Requires the programmer to explicitley define the data type when creating it (e.g. when preceiding with an int when defining a variable)</li>
<li>Statically typed languages are generally compiled</li>
<li>Has the advantage that by telling the computer upfrtno what data you are dealing with, errors can be caught before deployment. Also errors can be more obvious</li>
</ul>
</p>

</p>
  </div>
  <div class="column2"><h3>Dynamic typing (e.g. Python, JavaScript, PhP and Pearl)</h3>
    <p>
<ul>
<li>Language guesses our data type (.e.g whether a string, integer or float)</li>
<li>Generally interpreted languages</li>
<li>One advantage is potentially less code needed, as not having to define data type each time</li>
<li>Can be more flexible as same variable can have a different type at different times during the execution</li> 
</ul>
</div>
</div>

</p>
Key terms to look at in the <a href="glossary.html">Glossary</a> for this unit:
<ul>
<li>Assembly language</li>
<li>Runtime</li>
<li>Source code</li>
</ul>

</ul>
								</div>
							</section>
											<!-- Main -->
					<div id="main">

						<!-- two -->
							<section id="Two">
								<div class="inner">
									<header class="major">
										<h2>Unit 4 - Exploring Programming Language Concepts</h2>
									</header>
Three aspects of secure architecture (CIA triad):
<ul>
<li>Confidentialility: restrict unauthorised use of data</li>
<li>Integrity: system free from external manipulation, i.e. data can be trusted</li>
<li>Availability: level of service corresponds with its SLA. Also, system will not deny service to authorised users</li>
</ul>
The following helps to achieve this:
<ul>
<li>Authentication (verifies identity, e.g. public keys)</li>
<li>Authorisation (rights to specific users</li>
<li>Non-reputability (a user cannot deny behaviour or transactions on a system</li>
</ul>
Design patterns: these are guidelines ways to organise code for common problems in a way that is widely accepted by the software community. They are usually language netral, and details the name and structure of the solution (this also makes them readily identifiable).
They are not algarithms (i.e. step by step solutions) nor software architecture (which is the framework within which coding is housed).
<p>
Design antipatterns: these are where a pattern does not exist for a particular problem. An anti-pattern is something that appears to be an appropriate solution, but is not. These antipatterns have already been proved ineffective so exist to save programmers from wasting their time with these.
</p>
<p>Design errors/coding smells: antipatterns, these indicate a potential bug in teh application</p>
<p>Particularly important terminology from this week (some programers use the below terms interchangeably and not in the correct way):</p>
<ul>
<li>Python script: a file containing commands ina logical order. Has to produce an output. Indeded to be run directly.</li>
<li>Python module: can inport into script, but does not run in itself.</li>
<li>Python packages: a collection of related modules taht come bundled together  </li>
<li>Python standard library: a collection of moudles and packages that come with the standard python installation and can just import into your scripts, e.g. JSON</li>
</ul>

</p>
Recursion is a function that calls itself. It is  a way of dividing problems into smaller problems that can use the same algorithm. Must have an end condition to know if should recall itself or not. Associated heavily with functional programming.
</p>

Key terms to look at in the <a href="glossary.html">Glossary</a> for this unit:
<ul>
<li>Casting</li>
<li>Code refractoring</li>
<li>Garbage collection</li>
<li>Inheritance </li>
<li>Pointers</li>
<li>Polymorphism</li>
<li>Queue</li>


</ul>

								</div>
							</section>
											<!-- Main -->
					<div id="main">

						<!-- two -->
							<section id="Two">
								<div class="inner">
									<header class="major">
										<h2>Unit 5: An Introduction to Testing</br>
										Unit 6: Using Linters to Support Python Testing</h2>
									</header>
Validation is the ability to fulfil the customers need. Verification is the ability to fulful the defined specification. Both are needed, but sometimes only one of these is met.
<p>
Quality assurance testing is the process of ensuring the quality of the software being released.
</p>
Developing a test plan includes:
<ul>
<li>What type of testing</li>
<li>What needs testing and when</li>
</ul>
<p>
White-box testing looks at the structure of the code. It invovles the internal system being known to the tester. An example of this is unit testing. These structural based test (i.e. they consider the structure of the system).
<br>
Black-box testing looks at the overall functionality (for example equivalency or use-case testing). Can start designing black-box testing before the code is even written. These are specification based  (i.e. the tester can find missing functionalities).
</p>
There are many benefits of automating testing. Some areas cannot be automated easily, for example user-acceptability testing.

</p>
There are various approaches to testing (it is good practice to include as many of these as possible):

<ul>
<li>Functional testing: customer requirements from the specification have been fulfilled.</li>
<li>Usability testing: a user evaluates the system.</li>
<li>Compatability testing: works on different hardware and softare platforms.</li>
<li>Regression testing: changes to the system have not stopped a compenant working.</li>
<li>Acceptance testing: will the system fuilfill the user requirments enough for them to accept it (can involves the developer working with the customer).</li>
<li>Performance testing: does it meet perfrmances requirements (for example load or stress testing).</li>
<li>Big bang testing: testing the system as a whole</li>
</p>
Security related approach:
<ul>
Vulnerability assessment and penetration testing. The former helps us to determine where we need to do penetration testing (which is the simulation of an attack/putting a system under pressure))
</ul>
<p>
Testing can also be divided into dynamic (carried out while the code is being run) and static (based upon the internal structure of the software). These work well together, with the latter validating the findings of the former.
</p>
Experience-based testing involves the tester using their knowledge to guess where erros may exist.
<p>
MC/DC: testing only important combinations??????
</p>
Linters: a lint is a small mistake in code. A linter helps to indentify these. Most IDEs run these in the background. Some are language indpendent and some are specific. Python specific examples include Flake8 and PyLint.
</p>
Reflection of knowledge from this week: learning by linting (reference).
<p>
</p>

Key terms to look at in the <a href="glossary.html">Glossary</a> for this unit:
<ul>
<li>Cyclometric complexity</li>
<li>Poison package</li>
<li>Testability</li>
</ul>



								</div>
							</section>
											<!-- Main -->
					<div id="main">

						<!-- two -->
							<section id="Two">
								<div class="inner">
									<header class="major">
										<h2>Unit 7: Introduction to Operating Systems</h2>
									</header>
									
									
An Operating system is a programme to run all other software and hardware.
<br>
There are four main functions of an OS:
<ul>
<li>Providing a number of interfaces</li>
	<ul>
	<li>Graphical User Interface (GUI)</li>
	<li>Command Line Interface (CLI)</li>
	<li>API (providing an interface for other programmes)</li>
	<li>Device Drivers</li>
	</ul></li>

<li>Resource management and scheduling
<ul>
<li>CPU</li>
<li>Memory and file systems</li>
<li> (please see the below information on the kernel)</li>
</ul>
</li>
<li>Abstraction and virtualisation (commonly used in virutal hosting environments). This may include:
<ul>
<li>Simulating hardware functionality (i.e. creating a virtual system from a single server)</li>
<li>OS virtualisation: software to allow a piece of hardware to run multiple OSs</li>
</ul>
</li>
<li>Services (for example a print service involving spooling data) and security </li>
</ul>


The kernel is the core of the OS. It is the first programme to load when the system starts and is stored in memory
until the system is closed down.
<br>
The kernel is responsible for:
<ul>
<li>Managing hardware</li>
<li>Managing memory</li>
<li>Process/task management (when a programme runs we call it a process)</li>
</ul>
Secure proctocols (HTTPS) usually use Public Key Infrastructure (PKI). This is:
</p>
Key terms to look at in the <a href="glossary.html">Glossary</a> for this unit:
<ul>
<li>Time-sharing</li>
<li>GNU project</li>
<li>Managed memory</li>

</ul>
								</div>
							</section>
											<!-- Main -->
					<div id="main">

						<!-- two -->
							<section id="Two">
								<div class="inner">
									<header class="major">
										<h2>Placeholder</h2>
									</header>

</p>
Key terms to look at in the <a href="glossary.html">Glossary</a> for this unit:
<ul>


</ul>
								</div>
							</section>
											<!-- Main -->
					<div id="main">

						<!-- two -->
							<section id="Two">
								<div class="inner">
									<header class="major">
										<h2>Placeholder</h2>
									</header>

</p>
Key terms to look at in the <a href="glossary.html">Glossary</a> for this unit:
<ul>


</ul>
								</div>
							</section>
											<!-- Main -->
					<div id="main">

						<!-- two -->
							<section id="Two">
								<div class="inner">
									<header class="major">
										<h2>Placeholder</h2>
									</header>

</p>
Key terms to look at in the <a href="glossary.html">Glossary</a> for this unit:
<ul>


</ul>
								</div>
							</section>
											<!-- Main -->
					<div id="main">

						<!-- two -->
							<section id="Two">
								<div class="inner">
									<header class="major">
										<h2>Placeholder</h2>
									</header>

</p>
Key terms to look at in the <a href="glossary.html">Glossary</a> for this unit:
<ul>


</ul>
								</div>
							</section>
											<!-- Main -->
					<div id="main">

						<!-- two -->
							<section id="Two">
								<div class="inner">
									<header class="major">
										<h2>Placeholder</h2>
									</header>

</p>
Key terms to look at in the <a href="glossary.html">Glossary</a> for this unit:
<ul>


</ul>
								</div>
							</section>



<!-- Section 12-->

							<section id="one">
								<div class="inner">
									<header class="major">
										<h2>Other Resources</h2></header>
<b><a href="https://jonny-droid.github.io/e-Portfolio/PDFs/mySkillMatrix.pdf">placeholder.</a></b></p>
<b><a href="https://jonny-droid.github.io/e-Portfolio/PDFs/actionPlan.pdf">placeholder</a></b></p>
<b><a href="https://jonny-droid.github.io/e-Portfolio/mod2Outcomes.html">placeholder.</a></b></p>
<b><a href="https://jonny-droid.github.io/e-Portfolio/assignmentReflections.html">placeholder</a></b>
</p>
</p>
References:
Pillai, A.B. (2017) Software Architecture with Python. Birmingham, UK. Packt Publishing Ltd.
<br>
Saltzer, J. & Schroeder, M. (1975) The Protection of Information in Computer Systems. Proceedings of the IEEE 63(9): 1278-1308.


<p>
Include somewhere:
Monolith and microservices have very different attack surfaces.
</p>


										</div>
</section>


		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>

